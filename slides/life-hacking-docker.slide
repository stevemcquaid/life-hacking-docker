Life-Hacking with Containers: Automate away your problems

Steve McQuaid
steve@stevemcquaid.com
https://github.com/stevemcquaid

: I am Steve McQuaid. I am a senior software engineer specializing in infrastructure engineering, specifically Kubernetes. Last year my wife and I relocated from the San Francisco Bay Area up to Carmel. More recently, I am actually taking the time to find the right new opportunity. So if you enjoy todays talk, tell your boss!
: And when I am not coding I enjoy whisky, running, golfing, and DJing. 

: Like many of you, I enjoy looking for ways to make my life easier + more efficient 
: In this talk I'd love to share some of the problems I've faced, from editing markdown to dealing with slow ISPs, and the lessons I've learned to make my life easier by dockerizing everything in sight


* Agenda
- Personal Project Philosophy
- Learnings
- Discuss Projects
.image images/swarm.gif _ 250

: Some rules that I follow when building hacks
: The challenges and solutions that I found to them
: Discuss various projects


* Why Containers?
- Save time
- It is FUN!
- Because we can
.image images/docker-bubbles.png _ 500
: Why would we want to dockerize and automate things?
: We want to be able to quickly do something that was previously laborious.
: Building things is enjoyable.
: Why not exercise our abilities and creativity


* Personal Project Philosophy
- Portable across environments
- Easy to understand
- Quick to build/use/modify
- Assume docker, bash, [make]
.image images/dockerize.jpg _ 400
: The main points I try to keep in mind while developing small projects for utility use are: 
: Portability - We want to be able to run anywhere - on a new machine easily. 
: Easily understood via highly commented code + documentation. Maintained by me. Make life easy. Favor legibility + code clarity   vs   efficiency + elegant oneliners. 
: Assume machines have docker & bash (or similar enough that we can patch things). Recently using make as a CLI for help commands. Avoiding docker flags.
: Finally, goal = if we need to change something in the future, it should be easy to do so.


* Requirements
- Utilze Convention
- Functional
- Portable
- Modifiable
- Clear >= Concise Logic
.image images/docker-container.jpg _ 300
: Given those principles, I use this mental checklist to make sure Im not creating a hassle for future me. 
: From an Infrastructure perspective, challenge = bootstrapping/dependency hell
: Docker specifically provides us with portability, and therefore you should be able to create something immediately functional out of the box.


* Basic Process
- Write the code to do task
- If you need deps then get a shell in ubuntu container, install what you need
- Convert to Dockerfile
- Wrap with utility scripts
- Create Documentation
.image images/docker-windows.png _ 250
: I usually begin by writing the code to do the task that I want
: Then if the libraries I'm using need some exotic underlying libs, like imagemagik, or some C extentions, I will get a shell in ubuntu container and install those.
: Put the commands I just ran manually to create the image, into the Dockerfile
: Wrap with some utility scripts
: Create documentation to remember how to use it when I come back to it


* Projects

: We will have interactive discussion in a few minutes since the life-hacks are probably what you are all interested in. I do want to first discuss some of the learnings that can apply to your projects.


* Learnings
- Iteration Time == fn(Compilation Time)
- Optimize Containers in Production
- Reuse patterns that work well
- Starter Code
- Make + Bash Scripts 
- Allow common interfaces to cli tools written in different languages on different platforms. Can include in bash_profile easily.
.image images/box-microservices.jpg _ 300
: Iteration is a function of compilation time
: So either have easy way to iterate, or install the deps locally, then convert to dockerfile.
: In python this means caching your dependencies to speed up builds
: In golang this means vendoring your deps via glide.yaml, or dev'ing locally
: Dont worry about optimizing containers for your hacks, worry about making them first. This took my OCD-self some time to realize. OK to use ubuntu + and multiline apt installs for development
: Find patterns that work well. Such as creating base images for your commonly used languages. And copy them for the future.
: Similarly, have starter code and use it.
: Wrap your commonly run commands to make life easy. I use bash and make to get small docker commands + flags
: Use patterns across languages. If your methodologies are similar itll be easy to switch languages for a specific project.
: Also, one pattern I use really helps me to have easy access from terminal on my computer. I use `make run` to exec a bash script in the vast majority of my projects. This makes it really easy to make a `bash_profile` alias to almost any project.


* More Learnings
- Comment Code
- Document everything via README.md + `make help` 
- Functional: `docker pull; docker run`
- Prebuilt argparse framework saves time
- Prebuilt pattern for sensitive information saves time
- Encryption is good
.image images/encrypt-file.png _ 200
: Comments are good
: Documentation is good
: Try and leave your pushed docker images in functional condition. It makes life much better.
: I mentioned language specific docker images. Having language specific boiler plate code saves A TON of time and can really speed up dev 
: Have common structure & a way to avoid committing keys to github is always a good thing. I am continuing to work two different approaches using veracrypt and a home brewed encryption utility.



* Dockerfile Best Practices
Unix processes not lightweight Virtual Machines

Application + Dependencies = Image
.image images/docker-fuck-no.jpg _ 350

: I wanted to add this as kind of a north star. One project I'm going to show you does break this rule... And thats bad. But whatever.
: Docker containers should be thought of as single processes, not full VMs
: Bundle your app binary with your deps to create an image.



* Dockerfile Best Practices
Building container images.
.code snippets/large-dockerfile
.caption Total size: 500MB
.image images/docker-fail.png _ 100
: Here is a large dockerfile that compiles and runs the code. Its quite bloated at 500MB. I am guilty of doing this. But my hacks arent running in production.



* Dockerfile Best Practices
Building container images

- Build applications in a dedicated build container or CI
- Ship build artifacts, not build environments

.code snippets/small-dockerfile
.caption Total size: 4MB
.image images/docker-slim.jpg _ 120
: Here is how it is supposed to be done. Build the binary, then run it in a microscopic container. Legit 100x reduction in size.
: Does anyone get the joke here?  Its a SLIM image... a SLIM DOCKER image.. SLIM DOCKER... DOCKER SLIM... THE PANTS ARE DOCKER SLIM FIT

* Projects
: Now for the fun part. I want the rest of the talk to be extremely interactive, so feel free to speak up and ask questions, clarifications, suggest improvements, or share your experiences. Or with heavy pursuasion, I can test our luck with the demo gods to run live demos.

* Projects
- [[projects/domain-bot/domain-bot.slide#2][Domain Availablity Checker]]
- [[projects/internet-speedtest-docker/internet-speedtest-docker.slide#1][Internet Speedtest Dashboard]]
- [[projects/cloudflare-dyndns/cloudflare-dyndns.slide#2][DynDNS on CloudFlare (in Golang)]]
- [[projects/life-hacking-docker/life-hacking-docker.slide#2][GoPresent/This slide deck]]
- [[projects/vim-ide/vim-ide.slide#2][VIM IDE with Golang Autocompletion]]
- [[projects/grip-docker/grip-docker.slide#2][Markdown Viewer (Realtime, Github Formatting)]]
- [[projects/toolbox/toolbox.slide#2][Utility debugger/”Toolbox”]]
- [[projects/otp/otp.slide#2][2FA/Gauth One Time Passcodes]]
- [[projects/grypt/grypt.slide#2][Encryption Utility in Golang]]
- [[projects/sigterm/sigterm.slide#2][SIGTERM Cleanup: Pattern in Golang]]
- [[projects/gaws/gaws.slide#2][Golang AWS Docker OneLiner]]
- [[projects/docker-weechat-otr/docker-weechat-otr.slide#2][Chat in Terminal with: Slack, Hangouts, Facebook Chat, IRC, XMPP, Twitter ]]

: Unlock Protected PDF (avoid forcibly using Adobe Software)
: md2pdf?
: https://github.com/stevemcquaid/haproxy
: https://github.com/stevemcquaid/veracrypt
 





### weechat-docker-otr
    #### Purpose
    Be able to access all chat platforms from the command line. Be able to communicate with only a terminal
    #### Challenges
    Dependency hell. Learning weechat commands. Setup of accounts/config file & state managements
    #### Learnings/Solutions
    Break out apt installs. Encrypt config files. Built own documentation if it would take too long to automate your own solution.
### internet-speedtest-docker
    #### Purpose
    Monitor the real-time speed from ISP. Graph it to know when stuff breaks and when speeds slow.
    #### Challenges
    Converting compose to k8s. Running persistantly somewhere in local network. Exposing the docker port beyond minikube
    #### Learnings/Solutions
    Have templates. Have a dev machine run kubernetes. Use haproxy in docker container to redirect to the minikube port

### haproxy
    #### Purpose
    Be able to redirect traffic at will. (Reverse Proxy)
    #### Challenges
    Forward traffic to a different ip/port, Easily mapping to/from ports in a simple manner
    #### Learnings/Solutions
    Use haproxy in a docker container. Use simple config file
### grip
    #### Purpose
    View rendered output of github-flavor markdown live on local computer.
    #### Challenges
    Be portable across Mac/Linux. Handle live refreshes in browser. Rate limiting. Be accessible from any shell context 
    #### Learnings/Solutions
    Its easy to alias shell scripts in bash profile. Make becomes a wrapper. Have a common binding for languages to make life easy.
### otp/gauth
    #### Purpose
    Be able to backup/access/use 2FA codes on a computer
    #### Challenges
    Security of configuration codes. golang language bindings
    #### Learnings/Solutions
    Veracrypt allows in-memory storage of sensitive information with a common mounting point. Allows program to treat configs like regular files, but be securely stored at rest.
### grypt
    #### Purpose
    More secure in memory storage of secrets
    #### Challenges
    Codes should be accessible as files to other programs. Should reencrypt when the program exits.
    #### Learnings/Solutions
    sigterm pattern within golang program using docker's kill signal
### sigterm
    #### Purpose
    Create a starter pattern to allow cleanup when a SIGTERM is given in golang
    #### Challenges
    Assure sigterm gets handled correctly before being killed
    #### Learnings/Solutions
    Create sigterm handler - make sure docker send SIGTERM in the runtime environment. Document code and provide clean bindings for use.
### toolbox
    #### Purpose
    Create a utility debugger for poking around in unfamiliar environments. Often my starter Dockerfile on top of ubuntu:16.04
    #### Challenges
    Installing a bunch of packages and assuring none collide
    #### Learnings/Solutions
    Its not intended for production so there is no need to do oneliners.  Keep a dockerfile cache active for these massive containers.
### err-openstack
    #### Purpose
    Automate 
    #### Challenges
    Picking the right bot framework. Needs to communicate with slack but also openstack apis in a friendly language. Auth is hard. Also for development, should be able to run with new code and still work. Python should not have to install requirements every run.
    #### Learnings/Solutions
    Provide access to user on team (backed by Active Directory). Would want to create formal api in future and leave the bot to just handle Auth and slack parsing. Add requirements into container before code. Then dockerfile will be rebuild only when requirements change.
### pdf-title-rename
    #### Purpose
    I hoard ebooks. Often times the filename is mislabeled.  Have an easy way to rename large archives of ebooks
    #### Challenges
    Find the right solution prebuilt. Then Dockerize it. Create bindings to pass in files to docker container.
    #### Learnings/Solutions
    Using someone else's work is awesome!
### pdf-unlocker
    #### Purpose
    Need to sign document, but it requires Adobe Software to edit.
    #### Challenges
    Volume mounting. Bindings to enable future use easily
    #### Learnings/Solutions
    Using someone else's work is awesome! Streamlining the "Dockerization" process helps to save time!
### gaws
    #### Purpose
    Be able to quickly run a docker container exposed to the internet (ec2)
    #### Challenges
    You need to setup AWS IAM keys ahead of time, no API to allow UN/PS -> creds.
    #### Learnings/Solutions
    This was a challenge is restraint from adding everything as a CLI flag. Keep it simple, write clean code. Make reasonable assumptions (didnt need vpc or ami_id discovery to accomplish the task)
### vim-ide
    #### Purpose
    Be able to have the same full-featured development environment on any machine, anywhere in the world.
    #### Challenges
    I'm a nano user (GASP). I both needed to learn vim and the packaging around it (pathogen/vundle). There are some nearly complete prebuilt containers, but I needed to simplify to understand it. Also, its rare that I use a single language in a single day. I need support for python and golang, and a foundation to add support for anything else that comes up. (JSFOTW)
    #### Learnings/Solutions
    Use what works, (ubuntu) rather than a fancy alpine image that you can interact with and learn from. Be agile (make something that works, then iterate). Since this is a high-interaction container, worry less about the glue/wrappers around the container, and focus on getting the container functional. Dogfood. Build the container in the container... use vim to create the dockerfile and vim bindings as a mounted src volume.

